// Generated by CoffeeScript 1.3.3
(function() {
  var PI, PI2, addEdge, addnode, c, camera, clock, edgeGroup, geometry, init, parentDOM, particleCount, particleList, pivotList, radius, renderer, run, s, scene, stats, threeInit, updateLinks, updatePivots, v, worldMatrix;

  parentDOM = void 0;

  scene = void 0;

  camera = void 0;

  renderer = void 0;

  geometry = void 0;

  clock = new THREE.Clock();

  radius = 300;

  particleCount = 25;

  v = function(x, y, z) {
    return new THREE.Vector3(x, y, z);
  };

  c = function(x) {
    return Math.cos(x);
  };

  s = function(x) {
    return Math.sin(x);
  };

  PI = Math.PI;

  PI2 = Math.PI * 2;

  pivotList = void 0;

  edgeGroup = void 0;

  particleList = void 0;

  worldMatrix = new THREE.Matrix4();

  stats = new Stats();

  stats.setMode(1);

  stats.domElement.style.position = 'absolute';

  stats.domElement.style.left = '0px';

  stats.domElement.style.top = '0px';

  document.body.appendChild(stats.domElement);

  updatePivots = function() {
    var p, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = pivotList.length; _i < _len; _i++) {
      p = pivotList[_i];
      p[0].rotation.x += p[1] * 0.01;
      p[0].rotation.y += p[1] * 0.01;
      _results.push(p[0].rotation.z += p[1] * 0.01);
    }
    return _results;
  };

  updateLinks = function() {
    var line, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = edgeGroup.length; _i < _len; _i++) {
      line = edgeGroup[_i];
      _results.push((function(line) {
        var wp0, wp1;
        wp0 = line.properties.from.localToWorld(line.properties.from.position.clone()).normalize().multiplyScalar(radius);
        wp1 = line.properties.to.localToWorld(line.properties.to.position.clone()).normalize().multiplyScalar(radius);
        if (wp0.distanceTo(wp1) < radius / 3) {
          line.visible = true;
          return line.geometry.vertices = [wp0, wp1];
        } else {
          return line.visible = false;
        }
      })(line));
    }
    return _results;
  };

  run = function() {
    var time;
    stats.begin();
    time = clock.getElapsedTime() * 0.1;
    requestAnimationFrame(updatePivots);
    updateLinks();
    renderer.render(scene, camera);
    stats.end();
    return requestAnimationFrame(run);
  };

  addnode = function(mat, group, velo, position) {
    var particle, particlePivot;
    particlePivot = new THREE.Object3D();
    group.add(particlePivot);
    pivotList.push([particlePivot, velo]);
    particle = new THREE.Particle(mat);
    particleList.push(particle);
    particle.position = position;
    particlePivot.add(particle);
    return particle;
  };

  addEdge = function(nodeA, nodeB) {
    var line, wp0, wp1;
    wp0 = nodeA.localToWorld(nodeA.position.clone()).normalize().multiplyScalar(radius);
    wp1 = nodeB.localToWorld(nodeB.position.clone()).normalize().multiplyScalar(radius);
    geometry = new THREE.Geometry();
    geometry.vertices.push(wp0, wp1);
    scene.add(line = new THREE.Line(geometry, new THREE.LineBasicMaterial({
      color: 0xD57D22,
      opacity: 0.8
    })));
    line.properties = {
      from: nodeA,
      to: nodeB
    };
    return edgeGroup.push(line);
  };

  threeInit = function() {
    var sh, sw;
    parentDOM = document.getElementById("back");
    sw = 1000;
    sh = 500;
    camera = new THREE.PerspectiveCamera(75, sw / sh, 1, 10000);
    camera.position.z = 500;
    scene = new THREE.Scene();
    renderer = new THREE.CanvasRenderer();
    renderer.setSize(sw, sh);
    return parentDOM.appendChild(renderer.domElement);
  };

  init = function() {
    var canvas, circle_material, context, cs, edgePair, gradient, group, p, phi, theta, velo1, velo2, _, _i, _j, _k, _l, _len, _ref, _ref1;
    threeInit();
    canvas = document.createElement('canvas');
    cs = 25;
    canvas.width = cs;
    canvas.height = cs;
    canvas.loaded = true;
    context = canvas.getContext('2d');
    gradient = context.createRadialGradient(cs / 2, cs / 2, 0, cs / 2, cs / 2, cs / 3);
    gradient.addColorStop(0, 'rgba(213, 125, 34, 0.9)');
    gradient.addColorStop(1, 'rgba(89, 51, 12, 0.1)');
    context.fillStyle = gradient;
    context.arc(cs / 2, cs / 2, canvas.width / 3, 0, PI2, true);
    context.fill();
    circle_material = new THREE.ParticleBasicMaterial({
      map: new THREE.Texture(canvas),
      transparent: true
    });
    pivotList = [];
    particleList = [];
    edgeGroup = [];
    group = new THREE.Object3D();
    velo1 = 1;
    velo2 = -1;
    for (phi = _i = 0, _ref = PI / 5; 0 <= PI2 ? _i <= PI2 : _i >= PI2; phi = _i += _ref) {
      for (theta = _j = 0, _ref1 = PI / 5.5; 0 <= PI2 ? _j <= PI2 : _j >= PI2; theta = _j += _ref1) {
        addnode(circle_material, group, velo1, v(c(theta) * c(phi), c(theta) * s(phi), s(theta)).multiplyScalar(radius));
      }
    }
    for (_ = _k = 0; 0 <= particleCount ? _k <= particleCount : _k >= particleCount; _ = 0 <= particleCount ? ++_k : --_k) {
      addnode(circle_material, group, Math.random() * 2 - 1, v(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize().multiplyScalar(radius));
    }
    edgePair = (function() {
      var i, j, len, n0, n1, r;
      r = [];
      i = j = 0;
      len = particleList.length;
      while (i < len) {
        n0 = particleList[i];
        j = i + 1;
        while (j < len) {
          n1 = particleList[j];
          r.push([n0, n1]);
          j++;
        }
        i++;
      }
      return r;
    })();
    for (_l = 0, _len = edgePair.length; _l < _len; _l++) {
      p = edgePair[_l];
      addEdge(p[0], p[1]);
    }
    edgePair = null;
    scene.add(group);
    return run();
  };

  if (window.addEventListener) {
    window.addEventListener("load", init, false);
  } else if (window.attachEvent) {
    window.attachEvent("onload", init);
  } else {
    window.onload = init;
  }

}).call(this);
